<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#007AFF">
  <meta name="description" content="Vlog feed view of iCloud shared photo albums with mixed photo and video content. Videos are automatically transcribed and converted to blog posts with AI.">
  <meta name="keywords" content="icloud, photo album, vlog, feed, video transcription, blog, shared album">
  <meta name="application-name" content="Photo Album">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta id="apple-mobile-web-app-title" name="apple-mobile-web-app-title" content="Photo Album">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="iCloud Photo Album - Vlog Feed">
  <meta property="og:description" content="Vlog feed view of iCloud shared photo albums with automatic video transcription and AI-generated blog posts.">
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="iCloud Photo Album - Vlog Feed">
  <meta name="twitter:description" content="Vlog feed view of iCloud shared photo albums with automatic video transcription and AI-generated blog posts.">

  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/site.webmanifest" />
  
  <title>iCloud Photo Album - Vlog Feed</title>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      color: #333;
      overflow-x: hidden;
    }

    @media (prefers-color-scheme: dark) {
      body {
        background: #1a1a1a;
        color: #e0e0e0;
      }
    }

    .feed-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }

    @media (max-width: 768px) {
      .feed-container {
        padding: 12px;
      }
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
      position: relative;
    }

    .header h1 {
      font-size: 32px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 8px;
    }

    @media (prefers-color-scheme: dark) {
      .header h1 {
        color: #ffffff;
      }
    }

    .header p {
      color: #666;
      font-size: 16px;
    }

    @media (prefers-color-scheme: dark) {
      .header p {
        color: #b0b0b0;
      }
    }

    .notification-permission-banner {
      display: none;
      background: #007AFF;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      margin: 20px auto;
      max-width: 500px;
      text-align: center;
      font-size: 14px;
      line-height: 1.5;
    }

    .notification-permission-banner.show {
      display: block;
    }

    .notification-permission-banner button {
      background: white;
      color: #007AFF;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      margin-top: 8px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .notification-permission-banner button:active {
      opacity: 0.8;
    }

    @media (prefers-color-scheme: dark) {
      .notification-permission-banner {
        background: #0A84FF;
      }
    }

    .loading {
      text-align: center;
      padding: 60px 20px;
      color: #999;
    }

    .error {
      text-align: center;
      padding: 60px 20px;
      color: #d32f2f;
    }

    /* Photo Grid */
    .photo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 8px;
      margin-bottom: 24px;
    }

    @media (max-width: 768px) {
      .photo-grid {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 6px;
        margin-bottom: 20px;
      }
    }

    .photo-item {
      position: relative;
      aspect-ratio: 1;
      overflow: hidden;
      cursor: pointer;
      background: #e0e0e0;
      border-radius: 8px;
      transition: transform 0.2s ease;
    }

    .photo-item:hover {
      transform: scale(1.03);
    }

    .photo-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .photo-item.video-item {
      position: relative;
    }

    .photo-item .play-icon {
      position: absolute;
      bottom: 8px;
      left: 8px;
      width: 32px;
      height: 32px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
      pointer-events: none;
      z-index: 2;
      backdrop-filter: blur(4px);
    }

    .photo-item .play-icon::before {
      content: '▶';
      margin-left: 2px; /* Slight offset to center the triangle visually */
    }

    /* Vlog Post Card */
    .vlog-post {
      position: relative;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 32px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    @media (prefers-color-scheme: dark) {
      .vlog-post {
        background: #2a2a2a;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
    }

    .vlog-post:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    }

    @media (prefers-color-scheme: dark) {
      .vlog-post:hover {
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
      }
    }

    .vlog-thumbnail {
      width: 100%;
      aspect-ratio: 16 / 9;
      object-fit: cover;
      display: block;
      background: #000;
    }

    .vlog-content {
      padding: 20px;
    }

    .vlog-title {
      font-size: 24px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 12px;
      line-height: 1.3;
    }

    @media (prefers-color-scheme: dark) {
      .vlog-title {
        color: #ffffff;
      }
    }

    .vlog-text-preview {
      font-size: 16px;
      line-height: 1.6;
      color: #555;
      margin-bottom: 16px;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    @media (prefers-color-scheme: dark) {
      .vlog-text-preview {
        color: #b0b0b0;
      }
    }

    .vlog-meta {
      font-size: 14px;
      color: #999;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    @media (prefers-color-scheme: dark) {
      .vlog-meta {
        color: #888;
      }
    }

    .vlog-date {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .vlog-post {
      position: relative;
    }

    .vlog-post.processing {
      opacity: 0.7;
    }

    .vlog-post.processing::after {
      content: 'Processing...';
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
    }

    .vlog-post.has-augmentation {
      border-left: 3px solid #4CAF50;
    }

    /* Lightbox for photos */
    .lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 1000;
      cursor: pointer;
    }

    .lightbox.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-content {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 90vw;
      max-height: 90vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-image,
    .lightbox-video {
      max-width: 100%;
      max-height: 90vh;
      object-fit: contain;
      user-select: none;
      position: relative;
      z-index: 2;
    }

    .lightbox-thumbnail {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      z-index: 1;
      transition: opacity 0.3s ease;
    }

    .lightbox-image.loaded + .lightbox-thumbnail {
      opacity: 0;
      pointer-events: none;
    }

    .lightbox-close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
      backdrop-filter: blur(10px);
      font-family: Arial, sans-serif;
      z-index: 1001;
    }

    .lightbox-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
      backdrop-filter: blur(10px);
      z-index: 1001;
    }

    .lightbox-nav:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .lightbox-nav.prev {
      left: 20px;
    }

    .lightbox-nav.next {
      right: 20px;
    }

    .lightbox-info {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 12px 20px;
      border-radius: 20px;
      font-size: 14px;
      backdrop-filter: blur(10px);
      text-align: center;
      z-index: 99;
    }

    /* Vlog Lightbox */
    .vlog-lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 2000;
      overflow-y: auto;
    }

    .vlog-lightbox.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px 20px;
    }

    /* Prevent body scroll when lightbox is open */
    body.lightbox-open {
      overflow: hidden;
    }

    .vlog-lightbox-close {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
      backdrop-filter: blur(10px);
      font-family: Arial, sans-serif;
      z-index: 2001;
    }

    .vlog-lightbox-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .vlog-lightbox-content {
      max-width: 1200px;
      width: 100%;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 40px;
      align-items: start;
    }

    @media (max-width: 968px) {
      .vlog-lightbox-content {
        grid-template-columns: 1fr;
        gap: 30px;
      }

    }

    .vlog-lightbox-video {
      position: relative;
      width: 100%;
      /* aspect-ratio set dynamically via JavaScript based on video dimensions */
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      /* On desktop, constrain height so video doesn't exceed viewport */
      max-height: calc(100vh - 80px); /* Account for lightbox padding and spacing */
    }
    
    /* On mobile, remove max-height constraint to allow natural sizing */
    @media (max-width: 968px) {
      .vlog-lightbox-video {
        max-height: none;
      }
    }
    
    /* Small tablets in portrait mode - constrain vertical videos to fit viewport */
    @media (min-width: 600px) and (max-width: 968px) and (orientation: portrait) {
      .vlog-lightbox {
        padding: 16px;
        overflow-y: auto; /* Allow scrolling if content exceeds viewport */
      }
      
      .vlog-lightbox-video {
        max-height: calc(100vh - 350px); /* Leave room for header, text area, and padding */
        max-width: 90%; /* Slightly smaller to give breathing room */
        margin: 0 auto; /* Center the video */
        width: auto; /* Let video size naturally within constraints */
      }
      
      .vlog-lightbox-content {
        gap: 20px; /* Reduce gap on small tablets */
      }
      
      .vlog-lightbox-text {
        max-height: 40vh; /* Constrain text area to allow video to be visible */
      }
    }
    
    /* Desktop - ensure full width and proper sizing */
    @media (min-width: 969px) {
      .vlog-lightbox-video {
        width: 100% !important;
        max-width: 100% !important;
      }
    }

    .vlog-lightbox-video video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    /* Captions styling */
    .vlog-captions {
      position: absolute;
      bottom: 60px; /* Nudged up to avoid overlapping video controls */
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
      max-width: 90%;
      text-align: center;
      font-size: 16px;
      line-height: 1.4;
      pointer-events: none;
      z-index: 10;
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      display: none; /* Will be shown via JavaScript when native captions aren't available */
    }
    
    /* Hide native WebVTT captions when using custom overlay */
    .vlog-lightbox-video.using-custom-captions video::cue {
      display: none !important;
    }

    @media (max-width: 968px) {
      .vlog-captions {
        font-size: 14px;
        padding: 6px 12px;
        bottom: 55px; /* Nudged up to avoid overlapping video controls on mobile */
      }
    }

    .vlog-lightbox-text {
      color: white;
      overflow-y: auto;
      max-height: calc(100vh - 40px);
      padding-right: 8px;
    }

    .vlog-lightbox-title {
      font-size: 32px;
      font-weight: 600;
      margin-bottom: 20px;
      line-height: 1.3;
    }

    .vlog-lightbox-date {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .vlog-lightbox-post {
      font-size: 18px;
      line-height: 1.8;
      color: rgba(255, 255, 255, 0.9);
    }

    .vlog-lightbox-post p {
      margin-bottom: 16px;
    }

    .vlog-lightbox-post p:last-child {
      margin-bottom: 0;
    }

    .vlog-lightbox-post h1,
    .vlog-lightbox-post h2,
    .vlog-lightbox-post h3,
    .vlog-lightbox-post h4,
    .vlog-lightbox-post h5,
    .vlog-lightbox-post h6 {
      margin-top: 24px;
      margin-bottom: 16px;
      font-weight: 600;
      line-height: 1.3;
    }

    .vlog-lightbox-post h1:first-child,
    .vlog-lightbox-post h2:first-child,
    .vlog-lightbox-post h3:first-child {
      margin-top: 0;
    }

    .vlog-lightbox-post ul,
    .vlog-lightbox-post ol {
      margin: 16px 0;
      padding-left: 24px;
    }

    .vlog-lightbox-post li {
      margin-bottom: 8px;
    }

    .vlog-lightbox-post strong {
      font-weight: 600;
    }

    .vlog-lightbox-post em {
      font-style: italic;
    }

    .vlog-lightbox-post code {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
    }

    .vlog-lightbox-post pre {
      background: rgba(255, 255, 255, 0.1);
      padding: 16px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 16px 0;
    }

    .vlog-lightbox-post pre code {
      background: none;
      padding: 0;
    }

    .vlog-lightbox-post blockquote {
      border-left: 3px solid rgba(255, 255, 255, 0.3);
      padding-left: 16px;
      margin: 16px 0;
      color: rgba(255, 255, 255, 0.7);
    }

    .vlog-lightbox-post a {
      color: rgba(255, 255, 255, 0.9);
      text-decoration: underline;
    }

    @media (max-width: 768px) {
      .vlog-lightbox {
        padding: 20px 12px;
      }

      .vlog-lightbox-content {
        gap: 24px;
      }

      .vlog-lightbox-title {
        font-size: 24px;
      }

      .vlog-lightbox-post {
        font-size: 16px;
      }

      .vlog-lightbox-close {
        top: 10px;
        right: 10px;
        width: 36px;
        height: 36px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="feed-container">
    <div class="header">
      <h1 id="feed-title">Vlog Feed</h1>
      <p id="feed-subtitle">Loading...</p>
      <div id="notification-permission-banner" class="notification-permission-banner">
        <div>Enable notifications to get badge updates when new photos are added</div>
        <button id="request-notification-permission">Enable Notifications</button>
      </div>
    </div>
    <div id="loading" class="loading">Loading feed...</div>
    <div id="error" class="error" style="display: none;"></div>
    <div id="feed" style="display: none;"></div>
  </div>

  <!-- Photo Lightbox -->
  <div id="lightbox" class="lightbox">
    <button class="lightbox-close" id="lightbox-close" aria-label="Close">×</button>
    <button class="lightbox-nav prev" id="lightbox-prev" aria-label="Previous">‹</button>
    <div class="lightbox-content">
      <img id="lightbox-image" class="lightbox-image" alt="" style="display: none;">
      <img id="lightbox-thumbnail" class="lightbox-thumbnail" alt="" style="display: none;">
      <video id="lightbox-video" class="lightbox-video" controls style="display: none;"></video>
      <div class="lightbox-info" id="lightbox-info"></div>
    </div>
    <button class="lightbox-nav next" id="lightbox-next" aria-label="Next">›</button>
  </div>

  <!-- Vlog Lightbox -->
  <div id="vlog-lightbox" class="vlog-lightbox">
    <button class="vlog-lightbox-close" id="vlog-lightbox-close" aria-label="Close">×</button>
    <div class="vlog-lightbox-content">
      <div class="vlog-lightbox-video">
        <video id="vlog-lightbox-video" controls playsinline></video>
        <div id="vlog-captions" class="vlog-captions" style="display: none;"></div>
      </div>
      <div class="vlog-lightbox-text">
        <h2 id="vlog-lightbox-title" class="vlog-lightbox-title"></h2>
        <div id="vlog-lightbox-date" class="vlog-lightbox-date"></div>
        <div id="vlog-lightbox-post" class="vlog-lightbox-post"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked@11/marked.min.js"></script>
  <script>
    let items = []; // Mixed array of photos and videos, sorted by date
    let photoItems = []; // Just photos (for lightbox navigation)
    let currentPhotoIndex = 0;
    let touchStartX = 0;
    let touchEndX = 0;
    let touchStartY = 0;
    let touchEndY = 0;
    let token = ''; // Album token from URL

    // Get token from URL path (e.g., /feed/B1v532ODWVjCzg)
    const pathParts = window.location.pathname.split('/').filter(Boolean);
    token = pathParts[1] || pathParts[pathParts.length - 1]; // Get token after /feed/

    if (!token) {
      document.getElementById('error').textContent = 'No album token provided. Access via /feed/:token';
      document.getElementById('error').style.display = 'block';
      document.getElementById('loading').style.display = 'none';
    } else {
      loadFeed(token);
    }

    async function loadFeed(token) {
      try {
        const response = await fetch(`/api/album/${token}`);
        if (!response.ok) {
          throw new Error(`Failed to load feed: ${response.statusText}`);
        }
        const data = await response.json();
        
        const allItems = data.photos || [];
        
        // Sort by dateCreated (newest first) - keeping original order for feed
        allItems.sort((a, b) => {
          const dateA = a.dateCreated ? new Date(a.dateCreated).getTime() : -Infinity;
          const dateB = b.dateCreated ? new Date(b.dateCreated).getTime() : -Infinity;
          return dateB - dateA;
        });
        
        if (allItems.length === 0) {
          document.getElementById('error').textContent = 'No content found in this feed.';
          document.getElementById('error').style.display = 'block';
          document.getElementById('loading').style.display = 'none';
          return;
        }

        items = allItems;

        // Update header
        if (data.metadata) {
          // Update page title and iOS "Add to Home Screen" title
          // Priority: streamName > firstName > full name
          let pageTitle = null;
          let appTitle = null;
          
          if (data.metadata.streamName) {
            const streamName = data.metadata.streamName;
            pageTitle = `${streamName} - Vlog Feed`;
            appTitle = streamName.length > 12 ? streamName.substring(0, 12) : streamName;
            document.getElementById('feed-title').textContent = streamName;
          } else {
            const firstName = data.metadata.userFirstName || '';
            const lastName = data.metadata.userLastName || '';
            if (firstName || lastName) {
              const fullName = `${firstName} ${lastName}`.trim();
              pageTitle = `${fullName}'s Feed - Vlog Feed`;
              appTitle = firstName || (fullName.length > 12 ? fullName.substring(0, 12) : fullName);
            }
          }
          
          // Update browser tab title
          if (pageTitle) {
            document.title = pageTitle;
          }
          
          // Update iOS "Add to Home Screen" title
          const titleMeta = document.getElementById('apple-mobile-web-app-title');
          if (titleMeta && appTitle) {
            titleMeta.setAttribute('content', appTitle);
          }
          
          document.getElementById('feed-subtitle').textContent = `${items.length} post${items.length !== 1 ? 's' : ''}`;
        }

        // Pre-fetch augmentation status for all videos before rendering
        // This ensures we know which videos are skipped/augmented before we render
        // Use a timeout to avoid blocking on slow processing requests
        const videoItems = allItems.filter(item => isVideo(item));
        await Promise.all(videoItems.map(item => 
          Promise.race([
            fetchVideoAugmentation(token, item.photoGuid, false).catch(() => null),
            new Promise(resolve => setTimeout(() => resolve(null), 2000)) // 2 second timeout
          ])
        ));

        renderFeed();
        document.getElementById('loading').style.display = 'none';
        document.getElementById('feed').style.display = 'block';
      } catch (error) {
        console.error('Error loading feed:', error);
        document.getElementById('error').textContent = `Error: ${error.message}`;
        document.getElementById('error').style.display = 'block';
        document.getElementById('loading').style.display = 'none';
      }
    }

    function isVideo(item) {
      return item.mediaAssetType === 'video' || 
             (item.derivatives && Object.values(item.derivatives).some(d => d.url && d.url.includes('.mp4')));
    }

    function getBestThumbnail(item) {
      if (!item || !item.derivatives || Object.keys(item.derivatives).length === 0) {
        return null;
      }
      
      // Helper to extract numeric size from key (handles "1280-1" -> 1280)
      function extractSize(key) {
        const match = key.toString().match(/^(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
      }
      
      if (isVideo(item)) {
        // For videos, prefer JPG thumbnails (both original iCloud URLs and rewritten proxy URLs)
        const jpgDerivatives = Object.keys(item.derivatives)
          .filter(key => {
            const derivative = item.derivatives[key];
            if (!derivative || !derivative.url) return false;
            const url = derivative.url.toLowerCase();
            // Check for JPG files or rewritten proxy URLs (which always end in .jpg)
            return (url.includes('.jpg') || url.startsWith('/api/image/')) &&
                   !url.includes('.mp4');
          })
          .map(key => ({ key, size: extractSize(key) }))
          .sort((a, b) => a.size - b.size);
        
        if (jpgDerivatives.length > 0) {
          const preferred = jpgDerivatives.find(d => d.size >= 257) || jpgDerivatives[0];
          const result = item.derivatives[preferred.key];
          if (result && result.url) return result;
        }
        
        // Fallback: any non-video derivative (could be rewritten thumbnail or original JPG)
        const nonVideoDerivatives = Object.keys(item.derivatives)
          .filter(key => {
            const derivative = item.derivatives[key];
            if (!derivative || !derivative.url) return false;
            const url = derivative.url.toLowerCase();
            return !url.includes('.mp4');
          })
          .map(key => ({ key, size: extractSize(key) }))
          .sort((a, b) => a.size - b.size);
        
        if (nonVideoDerivatives.length > 0) {
          const result = item.derivatives[nonVideoDerivatives[0].key];
          if (result && result.url) return result;
        }
      }
      
      // For photos, prefer 257, then 333, then smallest available
      const sizes = Object.keys(item.derivatives)
        .filter(key => {
          const derivative = item.derivatives[key];
          if (!derivative || !derivative.url) return false;
          const url = derivative.url.toLowerCase();
          return !url.includes('.mp4');
        })
        .map(key => ({ key, size: extractSize(key) }))
        .sort((a, b) => a.size - b.size);
      
      if (sizes.length === 0) {
        // Last resort: return any derivative with a URL
        const anyDerivative = Object.values(item.derivatives).find(d => d && d.url);
        return anyDerivative || null;
      }
      
      const preferred = sizes.find(d => d.size >= 257) || sizes[0];
      const result = item.derivatives[preferred.key];
      return (result && result.url) ? result : null;
    }

    function getBestImage(item) {
      // Get the largest image derivative for lightbox display
      if (!item || !item.derivatives || Object.keys(item.derivatives).length === 0) {
        return null;
      }
      
      // Helper to extract numeric size from key (handles "1280-1" -> 1280)
      function extractSize(key) {
        const match = key.toString().match(/^(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
      }
      
      // Filter out videos and get all image derivatives
      const imageSizes = Object.keys(item.derivatives)
        .filter(key => {
          const derivative = item.derivatives[key];
          if (!derivative || !derivative.url) return false;
          const url = derivative.url.toLowerCase();
          return !url.includes('.mp4');
        })
        .map(key => ({ key, size: extractSize(key) }))
        .sort((a, b) => b.size - a.size); // Sort descending to get largest first
      
      if (imageSizes.length > 0) {
        const result = item.derivatives[imageSizes[0].key];
        return (result && result.url) ? result : null;
      }
      
      return null;
    }

    function getBestVideo(item) {
      // Helper to extract numeric size from key (handles "1280-1" -> 1280)
      function extractSize(key) {
        const match = key.toString().match(/^(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
      }
      
      const videoSizes = Object.keys(item.derivatives)
        .filter(key => {
          const derivative = item.derivatives[key];
          return derivative && derivative.url && derivative.url.toLowerCase().includes('.mp4');
        })
        .map(key => ({ key, size: extractSize(key) }))
        .sort((a, b) => b.size - a.size);
      
      if (videoSizes.length > 0) {
        return item.derivatives[videoSizes[0].key];
      }
      return null;
    }

    function formatDate(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      });
    }

    function formatDateShort(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: 'numeric'
      });
    }

    // Cache for video augmentations
    const videoAugmentations = new Map();

    // Fetch video augmentation from API
    async function fetchVideoAugmentation(albumToken, photoGuid, forceProcess = false) {
      const cacheKey = `${albumToken}_${photoGuid}`;
      
      // Check cache first
      if (videoAugmentations.has(cacheKey) && !forceProcess) {
        return videoAugmentations.get(cacheKey);
      }

      try {
        const url = `/api/video-augmentation/${encodeURIComponent(albumToken)}/${encodeURIComponent(photoGuid)}${forceProcess ? '?process=true' : ''}`;
        
        // Add AbortController for timeout on slow requests
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout
        
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          if (response.status === 404) {
            // Not found - don't trigger processing during pre-fetch, just return null
            // Processing will happen automatically when albums are fetched
            return null;
          }
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        
        // If processing in background, return null (will show placeholder)
        if (data.status === 'processing') {
          console.log(`Video augmentation processing for ${photoGuid}`);
          return null;
        }

        // Cache the result (including skipped state)
        if (data.skipped || data.transcription || data.blog) {
          videoAugmentations.set(cacheKey, data);
          return data;
        }

        return null;
      } catch (error) {
        // Handle timeout or other errors gracefully
        if (error.name === 'AbortError') {
          console.log(`Video augmentation fetch timeout for ${photoGuid}, will render as regular video`);
        } else {
          console.error(`Error fetching video augmentation for ${photoGuid}:`, error);
        }
        return null;
      }
    }

    // Generate content for vlog posts (with augmentation if available)
    async function generateVlogContent(item, albumToken) {
      // Try to get augmentation
      const augmentation = await fetchVideoAugmentation(albumToken, item.photoGuid);
      
      // Check if video was skipped (too short, etc.)
      if (augmentation && augmentation.skipped) {
        // Video was skipped - return null to indicate it should be treated as a regular video
        return null;
      }
      
      if (augmentation && augmentation.blog) {
        // Use actual blog content
        return {
          title: augmentation.blog.split('\n')[0].replace(/^#+\s*/, '') || `Vlog Entry - ${formatDateShort(item.dateCreated)}`,
          text: augmentation.blog,
          transcription: augmentation.transcription,
          hasAugmentation: true
        };
      } else if (augmentation && augmentation.transcription) {
        // Use transcription if blog not available
        return {
          title: `Vlog Entry - ${formatDateShort(item.dateCreated)}`,
          text: augmentation.transcription,
          transcription: augmentation.transcription,
          hasAugmentation: true
        };
      }

      // Fallback to placeholder
      return {
        title: `Vlog Entry - ${formatDateShort(item.dateCreated)}`,
        text: `Processing video transcription... This may take a few moments. Click to view video.`,
        hasAugmentation: false,
        processing: true
      };
    }

    function renderFeed() {
      const feed = document.getElementById('feed');
      feed.innerHTML = '';

      let currentPhotoGrid = null;
      
      // Build photoItems array: includes photos AND skipped videos (videos without augmentation)
      // Excludes only vlog posts (videos with augmentation)
      photoItems = [];
      items.forEach((item, index) => {
        if (!isVideo(item)) {
          // Regular photo - always include
          photoItems.push(item);
        } else {
          // Video - check if it's skipped or has no augmentation (should be in photo grid)
          const cacheKey = `${token}_${item.photoGuid}`;
          const cachedAugmentation = videoAugmentations.get(cacheKey);
          if (cachedAugmentation && cachedAugmentation.skipped) {
            // Skipped video - include in photoItems for navigation
            photoItems.push(item);
          } else if (!cachedAugmentation || !(cachedAugmentation.blog || cachedAugmentation.transcription)) {
            // Video with no augmentation or no blog/transcription - include in photoItems for navigation
            photoItems.push(item);
          }
          // Videos with augmentation (vlog posts) are excluded from photoItems
        }
      });

      // Render all items - we already know augmentation status from pre-fetch
      items.forEach((item, index) => {
        if (isVideo(item)) {
          // Check augmentation status (already fetched before rendering)
          const cacheKey = `${token}_${item.photoGuid}`;
          const cachedAugmentation = videoAugmentations.get(cacheKey);
          
          // If video was skipped OR has no augmentation, treat it as a regular photo
          // (render in photo grid, not as vlog post)
          if (cachedAugmentation && cachedAugmentation.skipped) {
            // Treat as photo - add to current grid or create new grid
            if (!currentPhotoGrid) {
              currentPhotoGrid = document.createElement('div');
              currentPhotoGrid.className = 'photo-grid';
            }

            const thumbnail = getBestThumbnail(item);
            const photoItem = document.createElement('div');
            photoItem.className = 'photo-item video-item';
            photoItem.dataset.itemIndex = index;

            if (thumbnail && thumbnail.url) {
              const img = document.createElement('img');
              img.src = thumbnail.url;
              img.alt = '';
              img.loading = 'lazy';
              photoItem.appendChild(img);
              
              // Add play icon overlay for videos
              const playIcon = document.createElement('div');
              playIcon.className = 'play-icon';
              photoItem.appendChild(playIcon);
            } else {
              // No thumbnail found - create a placeholder
              console.warn('Skipped video (no thumbnail) for photo grid:', item.photoGuid);
              console.warn('Available derivatives:', Object.keys(item.derivatives || {}));
              const placeholder = document.createElement('div');
              placeholder.style.cssText = 'width: 100%; aspect-ratio: 1; background: #333; display: flex; align-items: center; justify-content: center; color: #999; font-size: 14px;';
              placeholder.textContent = 'Video';
              photoItem.appendChild(placeholder);
            }

            photoItem.addEventListener('click', () => openVideoLightbox(index));
            currentPhotoGrid.appendChild(photoItem);
            return; // Skip vlog post creation
          }
          
          // Video has augmentation (blog/transcription) - render as vlog post
          // Only render vlog posts for videos that have augmentations
          if (cachedAugmentation && (cachedAugmentation.blog || cachedAugmentation.transcription)) {
            // Close current photo grid if open
            if (currentPhotoGrid) {
              feed.appendChild(currentPhotoGrid);
              currentPhotoGrid = null;
            }

            // Create vlog post card with actual content
            const vlogPost = document.createElement('div');
            vlogPost.className = 'vlog-post';
            vlogPost.dataset.itemIndex = index;
            vlogPost.id = `vlog-post-${index}`;

            const thumbnail = getBestThumbnail(item);
            if (thumbnail && thumbnail.url) {
              const thumbImg = document.createElement('img');
              thumbImg.src = thumbnail.url;
              thumbImg.className = 'vlog-thumbnail';
              thumbImg.alt = '';
              thumbImg.onerror = function() {
                console.error('Failed to load video thumbnail:', thumbnail.url, item);
                this.style.display = 'none';
              };
              vlogPost.appendChild(thumbImg);
            }

            const content = document.createElement('div');
            content.className = 'vlog-content';

            const title = document.createElement('h2');
            title.className = 'vlog-title';
            
            const textPreview = document.createElement('div');
            textPreview.className = 'vlog-text-preview';
            
            if (cachedAugmentation.blog) {
              // Use actual blog content
              const titleText = cachedAugmentation.blog.split('\n')[0].replace(/^#+\s*/, '') || `Vlog Entry - ${formatDateShort(item.dateCreated)}`;
              title.textContent = titleText;
              
              // Extract first paragraph as preview
              const preview = cachedAugmentation.blog
                .split('\n\n')[0]
                .replace(/^#+\s*/, '')
                .substring(0, 200);
              textPreview.textContent = preview + (preview.length >= 200 ? '...' : '');
              
              vlogPost.classList.add('has-augmentation');
            } else if (cachedAugmentation.transcription) {
              // Use transcription
              title.textContent = `Vlog Entry - ${formatDateShort(item.dateCreated)}`;
              const preview = cachedAugmentation.transcription.substring(0, 200);
              textPreview.textContent = preview + (preview.length >= 200 ? '...' : '');
              vlogPost.classList.add('has-augmentation');
            }
            
            content.appendChild(title);
            content.appendChild(textPreview);

            const meta = document.createElement('div');
            meta.className = 'vlog-meta';
            const date = document.createElement('div');
            date.className = 'vlog-date';
            date.textContent = formatDate(item.dateCreated);
            meta.appendChild(date);
            content.appendChild(meta);
            vlogPost.appendChild(content);

            vlogPost.addEventListener('click', () => openVlogLightbox(index));
            feed.appendChild(vlogPost);
          } else {
            // Video has no augmentation (skipped, processing, or not processed) - treat as regular video in photo grid
            if (!currentPhotoGrid) {
              currentPhotoGrid = document.createElement('div');
              currentPhotoGrid.className = 'photo-grid';
            }

            const thumbnail = getBestThumbnail(item);
            const photoItem = document.createElement('div');
            photoItem.className = 'photo-item video-item';
            photoItem.dataset.itemIndex = index;

            if (thumbnail && thumbnail.url) {
              const img = document.createElement('img');
              img.src = thumbnail.url;
              img.alt = '';
              img.loading = 'lazy';
              photoItem.appendChild(img);
              
              // Add play icon overlay for videos
              const playIcon = document.createElement('div');
              playIcon.className = 'play-icon';
              photoItem.appendChild(playIcon);
            } else {
              // No thumbnail found - create a placeholder
              const placeholder = document.createElement('div');
              placeholder.style.cssText = 'width: 100%; aspect-ratio: 1; background: #333; display: flex; align-items: center; justify-content: center; color: #999; font-size: 14px;';
              placeholder.textContent = 'Video';
              photoItem.appendChild(placeholder);
            }

            photoItem.addEventListener('click', () => openVideoLightbox(index));
            currentPhotoGrid.appendChild(photoItem);
            
            // Still load augmentation in background in case it finishes processing
            if (!cachedAugmentation || cachedAugmentation.status === 'processing') {
              loadVideoAugmentation(index, item, token, null);
            }
          }
        } else {
          // Photo - add to current grid or create new grid
          if (!currentPhotoGrid) {
            currentPhotoGrid = document.createElement('div');
            currentPhotoGrid.className = 'photo-grid';
          }

          const thumbnail = getBestThumbnail(item);
          if (!thumbnail || !thumbnail.url) {
            return; // Skip photos without thumbnails
          }

          const photoItem = document.createElement('div');
          photoItem.className = 'photo-item';
          photoItem.dataset.itemIndex = index;

          const img = document.createElement('img');
          img.src = thumbnail.url;
          img.alt = '';
          img.loading = 'lazy';
          img.dataset.itemIndex = index; // Store index for quick lookup
          photoItem.appendChild(img);

          photoItem.addEventListener('click', () => openPhotoLightbox(index));
          currentPhotoGrid.appendChild(photoItem);
        }
      });

      // Close any remaining photo grid
      if (currentPhotoGrid) {
        feed.appendChild(currentPhotoGrid);
      }
    }

    function openVideoLightbox(itemIndex) {
      const item = items[itemIndex];
      if (!item || !isVideo(item)) return;

      const video = getBestVideo(item);
      if (!video || !video.url) return;

      // Find index in photoItems array for navigation
      currentPhotoIndex = photoItems.findIndex(photo => photo === item);
      if (currentPhotoIndex === -1) {
        console.warn('Video item not found in photoItems array');
        return;
      }

      const lightbox = document.getElementById('lightbox');
      const lightboxImage = document.getElementById('lightbox-image');
      const lightboxVideo = document.getElementById('lightbox-video');
      const lightboxInfo = document.getElementById('lightbox-info');

      // Hide image, show video
      lightboxImage.style.display = 'none';
      lightboxVideo.src = video.url;
      lightboxVideo.style.display = 'block';
      
      // Handle video errors (expired URLs, etc.)
      const handleVideoError = async () => {
        const videoError = lightboxVideo.error;
        if (videoError && (videoError.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED || 
            videoError.code === MediaError.MEDIA_ERR_NETWORK || 
            videoError.code === MediaError.MEDIA_ERR_DECODE)) {
          console.warn(`Video playback error for ${item.photoGuid}, attempting to refresh album...`);
          
          // Try to refresh the album to get new URLs
          try {
            const refreshResponse = await fetch(`/api/album/${token}?refresh=true`);
            if (refreshResponse.ok) {
              const refreshedData = await refreshResponse.json();
              // Find the updated video URL
              const updatedItem = refreshedData.photos?.find(p => p.photoGuid === item.photoGuid);
              if (updatedItem) {
                const updatedVideo = getBestVideo(updatedItem);
                if (updatedVideo && updatedVideo.url && updatedVideo.url !== video.url) {
                  console.log(`Retrying with refreshed video URL for ${item.photoGuid}`);
                  // Update the item in our local array
                  Object.assign(item, updatedItem);
                  lightboxVideo.src = updatedVideo.url;
                  lightboxVideo.load();
                  return;
                }
              }
            }
          } catch (refreshError) {
            console.error('Failed to refresh album:', refreshError);
          }
          
          // If refresh didn't work, show error message
          console.error(`Video failed to load for ${item.photoGuid}:`, videoError);
          lightboxInfo.innerHTML = `<div style="color: #ff6b6b;">Video failed to load. The URL may have expired.</div>`;
        }
      };
      
      lightboxVideo.addEventListener('error', handleVideoError, { once: true });

      const caption = item.caption || '';
      const date = formatDate(item.dateCreated);
      lightboxInfo.innerHTML = caption 
        ? `<div>${caption}</div><div style="margin-top: 4px; opacity: 0.8; font-size: 12px;">${date}</div>`
        : `<div>${date}</div>`;

      lightbox.classList.add('active');
      document.body.classList.add('lightbox-open');
    }

    function openPhotoLightbox(itemIndex) {
      const item = items[itemIndex];
      if (!item) return;

      // Handle videos - open video lightbox for skipped videos (regular videos should use vlog lightbox)
      if (isVideo(item)) {
        const cacheKey = `${token}_${item.photoGuid}`;
        const cachedAugmentation = videoAugmentations.get(cacheKey);
        // If video is skipped, open in regular video lightbox (treat as regular video)
        if (cachedAugmentation && cachedAugmentation.skipped) {
          openVideoLightbox(itemIndex);
        } else {
          // Regular video with augmentation - use vlog lightbox
          openVlogLightbox(itemIndex);
        }
        return;
      }

      // Find index in photoItems array
      currentPhotoIndex = photoItems.findIndex(photo => photo === item);
      if (currentPhotoIndex === -1) return;

      // Get the largest image for lightbox (not thumbnail)
      const bestImage = getBestImage(item);
      if (!bestImage || !bestImage.url) return;

      const lightbox = document.getElementById('lightbox');
      const lightboxImage = document.getElementById('lightbox-image');
      const lightboxThumbnail = document.getElementById('lightbox-thumbnail');
      const lightboxVideo = document.getElementById('lightbox-video');
      const lightboxInfo = document.getElementById('lightbox-info');

      // Hide video, reset image state
      lightboxVideo.style.display = 'none';
      lightboxImage.style.display = 'none';
      lightboxImage.classList.remove('loaded');

      // Show thumbnail immediately - reuse already-loaded grid image
      const gridImg = document.querySelector(`.photo-item img[data-item-index="${itemIndex}"]`);
      if (gridImg && gridImg.complete && gridImg.naturalWidth > 0) {
        // Use the EXACT same src from the grid image (already loaded and cached)
        lightboxThumbnail.src = gridImg.src;
        lightboxThumbnail.style.display = 'block';
        lightboxThumbnail.style.opacity = '1';
        lightboxThumbnail.style.filter = 'none';
      } else {
        // Fallback: if grid image not found, get thumbnail
        const thumbnail = getBestThumbnail(item);
        if (thumbnail && thumbnail.url !== bestImage.url) {
          lightboxThumbnail.src = thumbnail.url;
          lightboxThumbnail.style.display = 'block';
          lightboxThumbnail.style.opacity = '0.5';
          lightboxThumbnail.style.filter = 'blur(10px)';
        } else {
          lightboxThumbnail.style.display = 'none';
        }
      }

      // Load full image
      lightboxImage.onload = function() {
        lightboxImage.classList.add('loaded');
        lightboxImage.style.display = 'block';
        // Hide thumbnail when full image loads
        lightboxThumbnail.style.display = 'none';
      };
      lightboxImage.src = bestImage.url;

      const caption = item.caption || '';
      const date = formatDate(item.dateCreated);
      lightboxInfo.innerHTML = caption 
        ? `<div>${caption}</div><div style="margin-top: 4px; opacity: 0.8; font-size: 12px;">${date}</div>`
        : `<div>${date}</div>`;

      lightbox.classList.add('active');
      document.body.classList.add('lightbox-open');
    }

    // Load video augmentation asynchronously and update the UI
    // This is called after initial render for videos that are still processing
    async function loadVideoAugmentation(index, item, albumToken, vlogPostElement) {
      try {
        const augmentation = await fetchVideoAugmentation(albumToken, item.photoGuid, false);
        
        // If video was skipped or has no augmentation, it's already rendered as a photo item
        // No action needed - it's already in the photo grid
        
        // If video now has augmentation and was rendered as a photo, we'd need to convert it
        // But for now, we'll leave it as-is since it's rare for processing to complete
        // during a page session. The next page load will render it correctly.
        
        if (augmentation && (augmentation.blog || augmentation.transcription) && vlogPostElement) {
          // Update existing vlog post with new content
          const titleElement = vlogPostElement.querySelector('.vlog-title');
          const textPreviewElement = vlogPostElement.querySelector('.vlog-text-preview');
          
          if (titleElement && textPreviewElement) {
            if (augmentation.blog) {
              const titleText = augmentation.blog.split('\n')[0].replace(/^#+\s*/, '') || `Vlog Entry - ${formatDateShort(item.dateCreated)}`;
              titleElement.textContent = titleText;
              const preview = augmentation.blog
                .split('\n\n')[0]
                .replace(/^#+\s*/, '')
                .substring(0, 200);
              textPreviewElement.textContent = preview + (preview.length >= 200 ? '...' : '');
              vlogPostElement.classList.remove('processing');
              vlogPostElement.classList.add('has-augmentation');
            } else if (augmentation.transcription) {
              titleElement.textContent = `Vlog Entry - ${formatDateShort(item.dateCreated)}`;
              const preview = augmentation.transcription.substring(0, 200);
              textPreviewElement.textContent = preview + (preview.length >= 200 ? '...' : '');
              vlogPostElement.classList.remove('processing');
              vlogPostElement.classList.add('has-augmentation');
            }
          }
        }
      } catch (error) {
        console.error(`Error loading augmentation for video ${index}:`, error);
      }
    }

    // Setup video captions from transcription and timestamps
    function setupVideoCaptions(videoElement, augmentation) {
      const captionsDiv = document.getElementById('vlog-captions');
      
      // Remove existing track elements
      const existingTracks = videoElement.querySelectorAll('track');
      existingTracks.forEach(track => track.remove());
      
      // Clear captions div
      if (captionsDiv) {
        captionsDiv.textContent = '';
        captionsDiv.style.display = 'none';
      }
      
      if (!augmentation || !augmentation.transcription || !augmentation.timestamps || !augmentation.points) {
        return; // No caption data available
      }
      
      const { transcription, timestamps, points } = augmentation;
      
      // Create WebVTT format subtitles
      let vttContent = 'WEBVTT\n\n';
      
      // Group words by timestamps to create caption cues
      for (let i = 0; i < timestamps.length; i++) {
        const startTime = timestamps[i];
        const endTime = i < timestamps.length - 1 ? timestamps[i + 1] : startTime + 2000; // Default 2s if last
        
        // Get text for this segment
        const startPoint = points[i] || 0;
        const endPoint = i < points.length - 1 ? points[i + 1] : transcription.length;
        const captionText = transcription.substring(startPoint, endPoint).trim();
        
        if (!captionText) continue;
        
        // Format times as WebVTT (HH:MM:SS.mmm)
        const formatTime = (ms) => {
          const hours = Math.floor(ms / 3600000);
          const minutes = Math.floor((ms % 3600000) / 60000);
          const seconds = Math.floor((ms % 60000) / 1000);
          const milliseconds = ms % 1000;
          return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        };
        
        vttContent += `${i + 1}\n`;
        vttContent += `${formatTime(startTime)} --> ${formatTime(endTime)}\n`;
        vttContent += `${captionText}\n\n`;
      }
      
      // Create blob URL for WebVTT
      const blob = new Blob([vttContent], { type: 'text/vtt' });
      const vttUrl = URL.createObjectURL(blob);
      
      // Add track element to video
      const track = document.createElement('track');
      track.kind = 'captions';
      track.label = 'English';
      track.srclang = 'en';
      track.src = vttUrl;
      track.default = true;
      videoElement.appendChild(track);
      
      // Detect mobile Safari (which often doesn't show native captions well)
      const isMobileSafari = /iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream;
      
      // Function to set up custom caption overlay
      function setupCustomCaptions() {
        if (!captionsDiv) return;
        
        // Mark container as using custom captions (for CSS)
        const videoContainer = videoElement.closest('.vlog-lightbox-video');
        if (videoContainer) {
          videoContainer.classList.add('using-custom-captions');
        }
        
        // Hide native captions by setting track mode to hidden
        if (videoElement.textTracks.length > 0) {
          videoElement.textTracks[0].mode = 'hidden';
        }
        
        const updateCaptions = () => {
          const currentTime = videoElement.currentTime * 1000; // Convert to ms
          
          // Find the current caption segment
          let currentCaption = '';
          for (let i = 0; i < timestamps.length; i++) {
            const startTime = timestamps[i];
            const endTime = i < timestamps.length - 1 ? timestamps[i + 1] : startTime + 2000;
            
            if (currentTime >= startTime && currentTime < endTime) {
              const startPoint = points[i] || 0;
              const endPoint = i < points.length - 1 ? points[i + 1] : transcription.length;
              currentCaption = transcription.substring(startPoint, endPoint).trim();
              break;
            }
          }
          
          if (currentCaption) {
            captionsDiv.textContent = currentCaption;
            captionsDiv.style.display = 'block';
          } else {
            captionsDiv.style.display = 'none';
          }
        };
        
        videoElement.addEventListener('timeupdate', updateCaptions);
        
        // Hide captions when video ends
        videoElement.addEventListener('ended', () => {
          if (captionsDiv) captionsDiv.style.display = 'none';
        });
        
        // Clean up blob URL when video is removed
        videoElement.addEventListener('loadstart', () => {
          URL.revokeObjectURL(vttUrl);
        });
      }
      
      // Wait for track to load, then decide which caption system to use
      track.addEventListener('load', () => {
        const textTrack = videoElement.textTracks[0];
        
        if (isMobileSafari) {
          // On mobile Safari, always use custom overlay for better control and touch compatibility
          setupCustomCaptions();
        } else {
          // On desktop Chrome/Firefox, try native captions first
          if (textTrack && textTrack.cues && textTrack.cues.length > 0) {
            textTrack.mode = 'showing';
            
            // Check after a short delay if native captions are actually displaying
            setTimeout(() => {
              // If native captions are working (activeCues exist), keep them and hide custom overlay
              // Otherwise, fall back to custom overlay
              if (textTrack.activeCues && textTrack.activeCues.length > 0) {
                // Native captions are working, ensure custom overlay is hidden
                const videoContainer = videoElement.closest('.vlog-lightbox-video');
                if (videoContainer) {
                  videoContainer.classList.remove('using-custom-captions');
                }
                if (captionsDiv) {
                  captionsDiv.style.display = 'none';
                }
              } else {
                // Native captions not working, use custom overlay
                setupCustomCaptions();
              }
            }, 500);
          } else {
            // No cues loaded, use custom overlay
            setupCustomCaptions();
          }
        }
      });
      
      // Fallback: if track doesn't load, use custom captions
      track.addEventListener('error', () => {
        setupCustomCaptions();
      });
    }

    async function openVlogLightbox(itemIndex) {
      const item = items[itemIndex];
      if (!item || !isVideo(item)) return;

      const video = getBestVideo(item);
      if (!video || !video.url) return;

      const vlogLightbox = document.getElementById('vlog-lightbox');
      const vlogVideo = document.getElementById('vlog-lightbox-video');
      const vlogTitle = document.getElementById('vlog-lightbox-title');
      const vlogDate = document.getElementById('vlog-lightbox-date');
      const vlogPost = document.getElementById('vlog-lightbox-post');

      const vlogContent = await generateVlogContent(item, token);
      
      // Get augmentation data for captions
      const augmentation = await fetchVideoAugmentation(token, item.photoGuid);
      
      vlogVideo.src = video.url;
      vlogTitle.textContent = vlogContent.title;
      vlogDate.textContent = formatDate(item.dateCreated);
      
      // Handle video errors (expired URLs, etc.)
      const handleVlogVideoError = async () => {
        const videoError = vlogVideo.error;
        if (videoError && (videoError.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED || 
            videoError.code === MediaError.MEDIA_ERR_NETWORK || 
            videoError.code === MediaError.MEDIA_ERR_DECODE)) {
          console.warn(`Video playback error for ${item.photoGuid}, attempting to refresh album...`);
          
          // Try to refresh the album to get new URLs
          try {
            const refreshResponse = await fetch(`/api/album/${token}?refresh=true`);
            if (refreshResponse.ok) {
              const refreshedData = await refreshResponse.json();
              // Find the updated video URL
              const updatedItem = refreshedData.photos?.find(p => p.photoGuid === item.photoGuid);
              if (updatedItem) {
                const updatedVideo = getBestVideo(updatedItem);
                if (updatedVideo && updatedVideo.url && updatedVideo.url !== video.url) {
                  console.log(`Retrying with refreshed video URL for ${item.photoGuid}`);
                  // Update the item in our local array
                  Object.assign(item, updatedItem);
                  vlogVideo.src = updatedVideo.url;
                  vlogVideo.load();
                  return;
                }
              }
            }
          } catch (refreshError) {
            console.error('Failed to refresh album:', refreshError);
          }
          
          // If refresh didn't work, show error message
          console.error(`Video failed to load for ${item.photoGuid}:`, videoError);
        }
      };
      vlogVideo.addEventListener('error', handleVlogVideoError, { once: true });
      
      // Setup captions if we have transcription and timestamps
      setupVideoCaptions(vlogVideo, augmentation);
      
      // Set aspect ratio based on video dimensions from metadata
      const vlogVideoContainer = document.querySelector('.vlog-lightbox-video');
      if (video.width && video.height && vlogVideoContainer) {
        const aspectRatio = video.width / video.height;
        vlogVideoContainer.style.aspectRatio = `${video.width} / ${video.height}`;
      } else {
        // Fallback to 16:9 if dimensions not available
        if (vlogVideoContainer) {
          vlogVideoContainer.style.aspectRatio = '16 / 9';
        }
      }
      
      // Display blog content as markdown using marked library
      if (vlogContent.hasAugmentation && vlogContent.text) {
        // Use marked to convert markdown to HTML
        if (typeof marked !== 'undefined') {
          vlogPost.innerHTML = marked.parse(vlogContent.text);
        } else {
          // Fallback to simple conversion if marked is not loaded
          let html = vlogContent.text
            .split('\n\n') // Paragraphs
            .map(para => {
              // Headers
              if (para.startsWith('### ')) {
                return `<h3>${para.substring(4)}</h3>`;
              } else if (para.startsWith('## ')) {
                return `<h2>${para.substring(3)}</h2>`;
              } else if (para.startsWith('# ')) {
                return `<h1>${para.substring(2)}</h1>`;
              }
              // Regular paragraph
              return `<p>${para.replace(/\n/g, '<br>')}</p>`;
            })
            .join('');
          vlogPost.innerHTML = html;
        }
      } else {
        // Placeholder or processing message
        vlogPost.innerHTML = `<p>${vlogContent.text.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>')}</p>`;
      }

      vlogLightbox.classList.add('active');
      document.body.classList.add('lightbox-open');
      vlogVideo.play();
    }

    // Lightbox controls
    document.getElementById('lightbox-close').addEventListener('click', (e) => {
      e.stopPropagation();
      document.getElementById('lightbox').classList.remove('active');
      document.body.classList.remove('lightbox-open');
      document.getElementById('lightbox-video').pause();
    });

    document.getElementById('lightbox').addEventListener('click', (e) => {
      if (e.target.id === 'lightbox') {
        document.getElementById('lightbox').classList.remove('active');
      document.body.classList.remove('lightbox-open');
        document.getElementById('lightbox-video').pause();
      }
    });

    document.getElementById('lightbox-prev').addEventListener('click', (e) => {
      e.stopPropagation();
      if (currentPhotoIndex > 0) {
        currentPhotoIndex--;
        const item = photoItems[currentPhotoIndex];
        const itemIndex = items.findIndex(i => i === item);
        if (itemIndex !== -1) {
          openPhotoLightbox(itemIndex);
        }
      }
    });

    document.getElementById('lightbox-next').addEventListener('click', (e) => {
      e.stopPropagation();
      if (currentPhotoIndex < photoItems.length - 1) {
        currentPhotoIndex++;
        const item = photoItems[currentPhotoIndex];
        const itemIndex = items.findIndex(i => i === item);
        if (itemIndex !== -1) {
          openPhotoLightbox(itemIndex);
        }
      }
    });

    // Touch swipe for vlog lightbox - only on video container
    let vlogTouchStartY = 0;
    let vlogTouchEndY = 0;
    
    const vlogVideoContainer = document.querySelector('.vlog-lightbox-video');
    if (vlogVideoContainer) {
      vlogVideoContainer.addEventListener('touchstart', (e) => {
        vlogTouchStartY = e.changedTouches[0].screenY;
      });

      vlogVideoContainer.addEventListener('touchend', (e) => {
        vlogTouchEndY = e.changedTouches[0].screenY;
        
        // Only handle swipe if vlog lightbox is active
        if (!document.getElementById('vlog-lightbox').classList.contains('active')) {
          return;
        }

        const swipeThreshold = 50;
        const diffY = vlogTouchStartY - vlogTouchEndY;

        // Check for vertical swipe down
        if (Math.abs(diffY) > swipeThreshold && diffY < 0) {
          // Swipe down - close vlog lightbox
          document.getElementById('vlog-lightbox').classList.remove('active');
          document.body.classList.remove('lightbox-open');
          const vlogVideo = document.getElementById('vlog-lightbox-video');
          if (vlogVideo) {
            vlogVideo.pause();
            vlogVideo.src = '';
          }
        }
      });
    }

    document.getElementById('vlog-lightbox-close').addEventListener('click', () => {
      const vlogLightbox = document.getElementById('vlog-lightbox');
      const vlogVideo = document.getElementById('vlog-lightbox-video');
      const vlogVideoContainer = document.querySelector('.vlog-lightbox-video');
      const vlogText = document.querySelector('.vlog-lightbox-text');
      
      vlogLightbox.classList.remove('active');
      document.body.classList.remove('lightbox-open');
      
      vlogVideo.pause();
      vlogVideo.src = '';
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      const lightbox = document.getElementById('lightbox');
      const vlogLightbox = document.getElementById('vlog-lightbox');

      if (lightbox.classList.contains('active')) {
        if (e.key === 'Escape') {
          lightbox.classList.remove('active');
          document.body.classList.remove('lightbox-open');
          document.getElementById('lightbox-video').pause();
        } else if (e.key === 'ArrowLeft') {
          document.getElementById('lightbox-prev').click();
        } else if (e.key === 'ArrowRight') {
          document.getElementById('lightbox-next').click();
        }
      } else if (vlogLightbox.classList.contains('active')) {
        if (e.key === 'Escape') {
          document.getElementById('vlog-lightbox-close').click();
        }
      }
    });

    // Service Worker registration and badge management
    // Only register on feed pages (not landing page)
    if ('serviceWorker' in navigator && token) {
      // Unregister all existing service workers first to force cache bust
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        return Promise.all(registrations.map((registration) => registration.unregister()));
      }).then(() => {
        // Wait a bit, then register with versioned URL to bust iOS cache
        const SW_VERSION = 'v2'; // Increment this to force service worker update
        return navigator.serviceWorker.register(`/sw.js?v=${SW_VERSION}`, {
          scope: window.location.pathname // Scope to current feed path
        });
      }).then((registration) => {
        console.log('Service Worker registered:', registration);
        
        // Check notification permission and show banner on iOS if needed
        checkNotificationPermission();
        
        // Update tracked tokens when feed loads
        updateTrackedTokens([token]);
      }).catch((error) => {
        console.error('Service Worker registration failed:', error);
      });
    }

    // Update tracked tokens in service worker
    function updateTrackedTokens(tokens) {
      if ('serviceWorker' in navigator) {
        // Wait for service worker to be ready
        navigator.serviceWorker.ready.then((registration) => {
          const channel = new MessageChannel();
          channel.port1.onmessage = (event) => {
            if (event.data.success) {
              console.log('Tracked tokens updated in service worker:', tokens);
              // Also trigger an immediate check
              if (registration.active) {
                registration.active.postMessage({ type: 'CHECK_NOW' });
              }
            } else {
              console.error('Failed to update tracked tokens:', event.data.error);
            }
          };
          
          if (navigator.serviceWorker.controller) {
            navigator.serviceWorker.controller.postMessage(
              { type: 'UPDATE_TRACKED_TOKENS', tokens },
              [channel.port2]
            );
          } else {
            // Service worker not controlling yet, try sending to registration
            if (registration.active) {
              registration.active.postMessage(
                { type: 'UPDATE_TRACKED_TOKENS', tokens },
                [channel.port2]
              );
            } else if (registration.waiting) {
              registration.waiting.postMessage(
                { type: 'UPDATE_TRACKED_TOKENS', tokens },
                [channel.port2]
              );
            }
          }
        }).catch((error) => {
          console.error('Error updating tracked tokens:', error);
        });
      }
    }

    // Clear badge when user opens the app
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
      const channel = new MessageChannel();
      navigator.serviceWorker.controller.postMessage(
        { type: 'CLEAR_BADGE' },
        [channel.port2]
      );
    }

    // Detect iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // Check notification permission and show banner if needed
    function checkNotificationPermission() {
      if (!('Notification' in window)) {
        return;
      }

      const currentPermission = Notification.permission;
      const banner = document.getElementById('notification-permission-banner');
      
      // Show banner on iOS if permission is default (not yet requested)
      if (isIOS && currentPermission === 'default' && banner) {
        banner.classList.add('show');
      } else if (banner) {
        banner.classList.remove('show');
      }

      console.log('Current notification permission:', currentPermission);
      if (currentPermission === 'granted') {
        console.log('Notification permission granted - badges will work');
      } else if (currentPermission === 'denied') {
        console.log('Notification permission denied - badges will not work');
        if (isIOS) {
          console.log('On iOS, enable notifications in Settings > Safari > [Site] > Notifications');
        }
      }
    }

    // Request notification permission on button click (iOS requires user interaction)
    const requestPermissionButton = document.getElementById('request-notification-permission');
    if (requestPermissionButton) {
      requestPermissionButton.addEventListener('click', async () => {
        if (!('Notification' in window)) {
          alert('Notifications are not supported in this browser.');
          return;
        }

        try {
          const result = await Notification.requestPermission();
          console.log('Notification permission result:', result);
          
          const banner = document.getElementById('notification-permission-banner');
          if (banner) {
            banner.classList.remove('show');
          }

          if (result === 'granted') {
            console.log('Notification permission granted - badges will work');
            
            // On iOS, also try setting badge from main thread
            if (isIOS && 'setAppBadge' in navigator) {
              try {
                await navigator.setAppBadge(1);
                console.log('Test badge set from main thread');
                setTimeout(() => {
                  navigator.clearAppBadge();
                }, 3000);
              } catch (badgeError) {
                console.error('Error setting badge from main thread:', badgeError);
              }
            }
            
            // Trigger immediate badge check
            if ('serviceWorker' in navigator) {
              navigator.serviceWorker.ready.then((registration) => {
                if (registration.active) {
                  registration.active.postMessage({ type: 'CHECK_NOW' });
                }
              });
            }
            
            // Optionally show a success message
            if (requestPermissionButton) {
              requestPermissionButton.textContent = 'Enabled!';
              requestPermissionButton.style.background = '#34C759';
              requestPermissionButton.style.color = 'white';
              setTimeout(() => {
                if (banner) banner.classList.remove('show');
              }, 2000);
            }
          } else if (result === 'denied') {
            console.log('Notification permission denied - badges will not work');
            if (isIOS) {
              alert('To enable badge notifications, go to Settings > Safari > [This Site] > Notifications and enable them.');
            }
          }
        } catch (error) {
          console.error('Error requesting notification permission:', error);
        }
      });
    }

    // Touch swipe for photo lightbox
    document.getElementById('lightbox').addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    });

    document.getElementById('lightbox').addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;
      handleSwipe();
    });

    function handleSwipe() {
      // Only handle swipe if lightbox is active
      if (!document.getElementById('lightbox').classList.contains('active')) {
        return;
      }

      const swipeThreshold = 50;
      const diffX = touchStartX - touchEndX;
      const diffY = touchStartY - touchEndY;

      // Check for vertical swipe (down) - prioritize over horizontal
      if (Math.abs(diffY) > swipeThreshold && Math.abs(diffY) > Math.abs(diffX)) {
        if (diffY < 0) {
          // Swipe down - close lightbox
          document.getElementById('lightbox').classList.remove('active');
          document.body.classList.remove('lightbox-open');
          document.getElementById('lightbox-video').pause();
        }
      } else if (Math.abs(diffX) > swipeThreshold) {
        // Horizontal swipe
        if (diffX > 0) {
          // Swipe left - next
          document.getElementById('lightbox-next').click();
        } else {
          // Swipe right - previous
          document.getElementById('lightbox-prev').click();
        }
      }
    }
  </script>
</body>
</html>

