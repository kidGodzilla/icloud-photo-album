<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#007AFF">
  <meta name="description" content="Vlog feed view of iCloud shared photo albums with mixed photo and video content.">
  <title>Feed View</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      color: #333;
      overflow-x: hidden;
    }

    @media (prefers-color-scheme: dark) {
      body {
        background: #1a1a1a;
        color: #e0e0e0;
      }
    }

    .feed-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }

    @media (max-width: 768px) {
      .feed-container {
        padding: 12px;
      }
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
    }

    .header h1 {
      font-size: 32px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 8px;
    }

    @media (prefers-color-scheme: dark) {
      .header h1 {
        color: #ffffff;
      }
    }

    .header p {
      color: #666;
      font-size: 16px;
    }

    @media (prefers-color-scheme: dark) {
      .header p {
        color: #b0b0b0;
      }
    }

    .loading {
      text-align: center;
      padding: 60px 20px;
      color: #999;
    }

    .error {
      text-align: center;
      padding: 60px 20px;
      color: #d32f2f;
    }

    /* Photo Grid */
    .photo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 8px;
      margin-bottom: 24px;
    }

    @media (max-width: 768px) {
      .photo-grid {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 6px;
        margin-bottom: 20px;
      }
    }

    .photo-item {
      position: relative;
      aspect-ratio: 1;
      overflow: hidden;
      cursor: pointer;
      background: #e0e0e0;
      border-radius: 8px;
      transition: transform 0.2s ease;
    }

    .photo-item:hover {
      transform: scale(1.03);
    }

    .photo-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    /* Vlog Post Card */
    .vlog-post {
      position: relative;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 32px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    @media (prefers-color-scheme: dark) {
      .vlog-post {
        background: #2a2a2a;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
    }

    .vlog-post:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    }

    @media (prefers-color-scheme: dark) {
      .vlog-post:hover {
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
      }
    }

    .vlog-thumbnail {
      width: 100%;
      aspect-ratio: 16 / 9;
      object-fit: cover;
      display: block;
      background: #000;
    }

    .vlog-content {
      padding: 20px;
    }

    .vlog-title {
      font-size: 24px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 12px;
      line-height: 1.3;
    }

    @media (prefers-color-scheme: dark) {
      .vlog-title {
        color: #ffffff;
      }
    }

    .vlog-text-preview {
      font-size: 16px;
      line-height: 1.6;
      color: #555;
      margin-bottom: 16px;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    @media (prefers-color-scheme: dark) {
      .vlog-text-preview {
        color: #b0b0b0;
      }
    }

    .vlog-meta {
      font-size: 14px;
      color: #999;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    @media (prefers-color-scheme: dark) {
      .vlog-meta {
        color: #888;
      }
    }

    .vlog-date {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .vlog-post {
      position: relative;
    }

    .vlog-post.processing {
      opacity: 0.7;
    }

    .vlog-post.processing::after {
      content: 'Processing...';
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
    }

    .vlog-post.has-augmentation {
      border-left: 3px solid #4CAF50;
    }

    /* Lightbox for photos */
    .lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 1000;
      cursor: pointer;
    }

    .lightbox.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-content {
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-image,
    .lightbox-video {
      max-width: 100%;
      max-height: 90vh;
      object-fit: contain;
      user-select: none;
    }

    .lightbox-close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
      backdrop-filter: blur(10px);
      font-family: Arial, sans-serif;
      z-index: 1001;
    }

    .lightbox-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
      backdrop-filter: blur(10px);
      z-index: 1001;
    }

    .lightbox-nav:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .lightbox-nav.prev {
      left: 20px;
    }

    .lightbox-nav.next {
      right: 20px;
    }

    .lightbox-info {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 12px 20px;
      border-radius: 20px;
      font-size: 14px;
      backdrop-filter: blur(10px);
      text-align: center;
    }

    /* Vlog Lightbox */
    .vlog-lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 2000;
      overflow-y: auto;
    }

    .vlog-lightbox.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px 20px;
    }

    /* Prevent body scroll when lightbox is open */
    body.lightbox-open {
      overflow: hidden;
    }

    .vlog-lightbox-close {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
      backdrop-filter: blur(10px);
      font-family: Arial, sans-serif;
      z-index: 2001;
    }

    .vlog-lightbox-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .vlog-lightbox-content {
      max-width: 1200px;
      width: 100%;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 40px;
      align-items: start;
    }

    @media (max-width: 968px) {
      .vlog-lightbox-content {
        grid-template-columns: 1fr;
        gap: 30px;
      }

      /* Picture-in-picture mode for video on mobile */
      .vlog-lightbox-video {
        position: relative;
        transition: all 0.3s ease;
      }

      .vlog-lightbox-video.pip-mode {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 160px;
        height: 90px;
        z-index: 2002;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      }

      .vlog-lightbox-video.pip-mode video {
        border-radius: 8px;
      }

      /* Add padding to text when video is in PIP mode */
      .vlog-lightbox-text.pip-active {
        padding-bottom: 120px; /* Space for PIP video + margin */
      }
    }

    .vlog-lightbox-video {
      width: 100%;
      aspect-ratio: 16 / 9;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
    }

    .vlog-lightbox-video video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .vlog-lightbox-text {
      color: white;
      overflow-y: auto;
      max-height: calc(100vh - 40px);
      padding-right: 8px;
    }

    .vlog-lightbox-title {
      font-size: 32px;
      font-weight: 600;
      margin-bottom: 20px;
      line-height: 1.3;
    }

    .vlog-lightbox-date {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .vlog-lightbox-post {
      font-size: 18px;
      line-height: 1.8;
      color: rgba(255, 255, 255, 0.9);
    }

    .vlog-lightbox-post p {
      margin-bottom: 16px;
    }

    .vlog-lightbox-post p:last-child {
      margin-bottom: 0;
    }

    .vlog-lightbox-post h1,
    .vlog-lightbox-post h2,
    .vlog-lightbox-post h3,
    .vlog-lightbox-post h4,
    .vlog-lightbox-post h5,
    .vlog-lightbox-post h6 {
      margin-top: 24px;
      margin-bottom: 16px;
      font-weight: 600;
      line-height: 1.3;
    }

    .vlog-lightbox-post h1:first-child,
    .vlog-lightbox-post h2:first-child,
    .vlog-lightbox-post h3:first-child {
      margin-top: 0;
    }

    .vlog-lightbox-post ul,
    .vlog-lightbox-post ol {
      margin: 16px 0;
      padding-left: 24px;
    }

    .vlog-lightbox-post li {
      margin-bottom: 8px;
    }

    .vlog-lightbox-post strong {
      font-weight: 600;
    }

    .vlog-lightbox-post em {
      font-style: italic;
    }

    .vlog-lightbox-post code {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
    }

    .vlog-lightbox-post pre {
      background: rgba(255, 255, 255, 0.1);
      padding: 16px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 16px 0;
    }

    .vlog-lightbox-post pre code {
      background: none;
      padding: 0;
    }

    .vlog-lightbox-post blockquote {
      border-left: 3px solid rgba(255, 255, 255, 0.3);
      padding-left: 16px;
      margin: 16px 0;
      color: rgba(255, 255, 255, 0.7);
    }

    .vlog-lightbox-post a {
      color: rgba(255, 255, 255, 0.9);
      text-decoration: underline;
    }

    @media (max-width: 768px) {
      .vlog-lightbox {
        padding: 20px 12px;
      }

      .vlog-lightbox-content {
        gap: 24px;
      }

      .vlog-lightbox-title {
        font-size: 24px;
      }

      .vlog-lightbox-post {
        font-size: 16px;
      }

      .vlog-lightbox-close {
        top: 10px;
        right: 10px;
        width: 36px;
        height: 36px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="feed-container">
    <div class="header">
      <h1 id="feed-title">Vlog Feed</h1>
      <p id="feed-subtitle">Loading...</p>
    </div>
    <div id="loading" class="loading">Loading feed...</div>
    <div id="error" class="error" style="display: none;"></div>
    <div id="feed" style="display: none;"></div>
  </div>

  <!-- Photo Lightbox -->
  <div id="lightbox" class="lightbox">
    <button class="lightbox-close" id="lightbox-close" aria-label="Close">×</button>
    <button class="lightbox-nav prev" id="lightbox-prev" aria-label="Previous">‹</button>
    <div class="lightbox-content">
      <img id="lightbox-image" class="lightbox-image" alt="" style="display: none;">
      <video id="lightbox-video" class="lightbox-video" controls style="display: none;"></video>
      <div class="lightbox-info" id="lightbox-info"></div>
    </div>
    <button class="lightbox-nav next" id="lightbox-next" aria-label="Next">›</button>
  </div>

  <!-- Vlog Lightbox -->
  <div id="vlog-lightbox" class="vlog-lightbox">
    <button class="vlog-lightbox-close" id="vlog-lightbox-close" aria-label="Close">×</button>
    <div class="vlog-lightbox-content">
      <div class="vlog-lightbox-video">
        <video id="vlog-lightbox-video" controls></video>
      </div>
      <div class="vlog-lightbox-text">
        <h2 id="vlog-lightbox-title" class="vlog-lightbox-title"></h2>
        <div id="vlog-lightbox-date" class="vlog-lightbox-date"></div>
        <div id="vlog-lightbox-post" class="vlog-lightbox-post"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked@11/marked.min.js"></script>
  <script>
    let items = []; // Mixed array of photos and videos, sorted by date
    let photoItems = []; // Just photos (for lightbox navigation)
    let currentPhotoIndex = 0;
    let touchStartX = 0;
    let touchEndX = 0;
    let token = ''; // Album token from URL

    // Get token from URL path (e.g., /feed/B1v532ODWVjCzg)
    const pathParts = window.location.pathname.split('/').filter(Boolean);
    token = pathParts[1] || pathParts[pathParts.length - 1]; // Get token after /feed/

    if (!token) {
      document.getElementById('error').textContent = 'No album token provided. Access via /feed/:token';
      document.getElementById('error').style.display = 'block';
      document.getElementById('loading').style.display = 'none';
    } else {
      loadFeed(token);
    }

    async function loadFeed(token) {
      try {
        const response = await fetch(`/api/album/${token}`);
        if (!response.ok) {
          throw new Error(`Failed to load feed: ${response.statusText}`);
        }
        const data = await response.json();
        
        const allItems = data.photos || [];
        
        // Sort by dateCreated (newest first) - keeping original order for feed
        allItems.sort((a, b) => {
          const dateA = a.dateCreated ? new Date(a.dateCreated).getTime() : -Infinity;
          const dateB = b.dateCreated ? new Date(b.dateCreated).getTime() : -Infinity;
          return dateB - dateA;
        });
        
        if (allItems.length === 0) {
          document.getElementById('error').textContent = 'No content found in this feed.';
          document.getElementById('error').style.display = 'block';
          document.getElementById('loading').style.display = 'none';
          return;
        }

        items = allItems;
        photoItems = allItems.filter(item => !isVideo(item));

        // Update header
        if (data.metadata) {
          if (data.metadata.streamName) {
            document.getElementById('feed-title').textContent = data.metadata.streamName;
          }
          document.getElementById('feed-subtitle').textContent = `${items.length} post${items.length !== 1 ? 's' : ''}`;
        }

        // Pre-fetch augmentation status for all videos before rendering
        // This ensures we know which videos are skipped/augmented before we render
        // Use a timeout to avoid blocking on slow processing requests
        const videoItems = allItems.filter(item => isVideo(item));
        await Promise.all(videoItems.map(item => 
          Promise.race([
            fetchVideoAugmentation(token, item.photoGuid, false).catch(() => null),
            new Promise(resolve => setTimeout(() => resolve(null), 2000)) // 2 second timeout
          ])
        ));

        renderFeed();
        document.getElementById('loading').style.display = 'none';
        document.getElementById('feed').style.display = 'block';
      } catch (error) {
        console.error('Error loading feed:', error);
        document.getElementById('error').textContent = `Error: ${error.message}`;
        document.getElementById('error').style.display = 'block';
        document.getElementById('loading').style.display = 'none';
      }
    }

    function isVideo(item) {
      return item.mediaAssetType === 'video' || 
             (item.derivatives && Object.values(item.derivatives).some(d => d.url && d.url.includes('.mp4')));
    }

    function getBestThumbnail(item) {
      if (!item || !item.derivatives || Object.keys(item.derivatives).length === 0) {
        return null;
      }
      
      // Helper to extract numeric size from key (handles "1280-1" -> 1280)
      function extractSize(key) {
        const match = key.toString().match(/^(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
      }
      
      if (isVideo(item)) {
        // For videos, prefer JPG thumbnails (both original iCloud URLs and rewritten proxy URLs)
        const jpgDerivatives = Object.keys(item.derivatives)
          .filter(key => {
            const derivative = item.derivatives[key];
            if (!derivative || !derivative.url) return false;
            const url = derivative.url.toLowerCase();
            // Check for JPG files or rewritten proxy URLs (which always end in .jpg)
            return (url.includes('.jpg') || url.startsWith('/api/image/')) &&
                   !url.includes('.mp4');
          })
          .map(key => ({ key, size: extractSize(key) }))
          .sort((a, b) => a.size - b.size);
        
        if (jpgDerivatives.length > 0) {
          const preferred = jpgDerivatives.find(d => d.size >= 257) || jpgDerivatives[0];
          const result = item.derivatives[preferred.key];
          if (result && result.url) return result;
        }
        
        // Fallback: any non-video derivative (could be rewritten thumbnail or original JPG)
        const nonVideoDerivatives = Object.keys(item.derivatives)
          .filter(key => {
            const derivative = item.derivatives[key];
            if (!derivative || !derivative.url) return false;
            const url = derivative.url.toLowerCase();
            return !url.includes('.mp4');
          })
          .map(key => ({ key, size: extractSize(key) }))
          .sort((a, b) => a.size - b.size);
        
        if (nonVideoDerivatives.length > 0) {
          const result = item.derivatives[nonVideoDerivatives[0].key];
          if (result && result.url) return result;
        }
      }
      
      // For photos, prefer 257, then 333, then smallest available
      const sizes = Object.keys(item.derivatives)
        .filter(key => {
          const derivative = item.derivatives[key];
          if (!derivative || !derivative.url) return false;
          const url = derivative.url.toLowerCase();
          return !url.includes('.mp4');
        })
        .map(key => ({ key, size: extractSize(key) }))
        .sort((a, b) => a.size - b.size);
      
      if (sizes.length === 0) {
        // Last resort: return any derivative with a URL
        const anyDerivative = Object.values(item.derivatives).find(d => d && d.url);
        return anyDerivative || null;
      }
      
      const preferred = sizes.find(d => d.size >= 257) || sizes[0];
      const result = item.derivatives[preferred.key];
      return (result && result.url) ? result : null;
    }

    function getBestVideo(item) {
      // Helper to extract numeric size from key (handles "1280-1" -> 1280)
      function extractSize(key) {
        const match = key.toString().match(/^(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
      }
      
      const videoSizes = Object.keys(item.derivatives)
        .filter(key => {
          const derivative = item.derivatives[key];
          return derivative && derivative.url && derivative.url.toLowerCase().includes('.mp4');
        })
        .map(key => ({ key, size: extractSize(key) }))
        .sort((a, b) => b.size - a.size);
      
      if (videoSizes.length > 0) {
        return item.derivatives[videoSizes[0].key];
      }
      return null;
    }

    function formatDate(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      });
    }

    function formatDateShort(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: 'numeric'
      });
    }

    // Cache for video augmentations
    const videoAugmentations = new Map();

    // Fetch video augmentation from API
    async function fetchVideoAugmentation(albumToken, photoGuid, forceProcess = false) {
      const cacheKey = `${albumToken}_${photoGuid}`;
      
      // Check cache first
      if (videoAugmentations.has(cacheKey) && !forceProcess) {
        return videoAugmentations.get(cacheKey);
      }

      try {
        const url = `/api/video-augmentation/${encodeURIComponent(albumToken)}/${encodeURIComponent(photoGuid)}${forceProcess ? '?process=true' : ''}`;
        
        // Add AbortController for timeout on slow requests
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout
        
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          if (response.status === 404) {
            // Not found - don't trigger processing during pre-fetch, just return null
            // Processing will happen automatically when albums are fetched
            return null;
          }
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        
        // If processing in background, return null (will show placeholder)
        if (data.status === 'processing') {
          console.log(`Video augmentation processing for ${photoGuid}`);
          return null;
        }

        // Cache the result (including skipped state)
        if (data.skipped || data.transcription || data.blog) {
          videoAugmentations.set(cacheKey, data);
          return data;
        }

        return null;
      } catch (error) {
        // Handle timeout or other errors gracefully
        if (error.name === 'AbortError') {
          console.log(`Video augmentation fetch timeout for ${photoGuid}, will render as regular video`);
        } else {
          console.error(`Error fetching video augmentation for ${photoGuid}:`, error);
        }
        return null;
      }
    }

    // Generate content for vlog posts (with augmentation if available)
    async function generateVlogContent(item, albumToken) {
      // Try to get augmentation
      const augmentation = await fetchVideoAugmentation(albumToken, item.photoGuid);
      
      // Check if video was skipped (too short, etc.)
      if (augmentation && augmentation.skipped) {
        // Video was skipped - return null to indicate it should be treated as a regular video
        return null;
      }
      
      if (augmentation && augmentation.blog) {
        // Use actual blog content
        return {
          title: augmentation.blog.split('\n')[0].replace(/^#+\s*/, '') || `Vlog Entry - ${formatDateShort(item.dateCreated)}`,
          text: augmentation.blog,
          transcription: augmentation.transcription,
          hasAugmentation: true
        };
      } else if (augmentation && augmentation.transcription) {
        // Use transcription if blog not available
        return {
          title: `Vlog Entry - ${formatDateShort(item.dateCreated)}`,
          text: augmentation.transcription,
          transcription: augmentation.transcription,
          hasAugmentation: true
        };
      }

      // Fallback to placeholder
      return {
        title: `Vlog Entry - ${formatDateShort(item.dateCreated)}`,
        text: `Processing video transcription... This may take a few moments. Click to view video.`,
        hasAugmentation: false,
        processing: true
      };
    }

    function renderFeed() {
      const feed = document.getElementById('feed');
      feed.innerHTML = '';

      let currentPhotoGrid = null;

      // Render all items - we already know augmentation status from pre-fetch
      items.forEach((item, index) => {
        if (isVideo(item)) {
          // Check augmentation status (already fetched before rendering)
          const cacheKey = `${token}_${item.photoGuid}`;
          const cachedAugmentation = videoAugmentations.get(cacheKey);
          
          // If video was skipped OR has no augmentation, treat it as a regular photo
          // (render in photo grid, not as vlog post)
          if (cachedAugmentation && cachedAugmentation.skipped) {
            // Treat as photo - add to current grid or create new grid
            if (!currentPhotoGrid) {
              currentPhotoGrid = document.createElement('div');
              currentPhotoGrid.className = 'photo-grid';
            }

            const thumbnail = getBestThumbnail(item);
            const photoItem = document.createElement('div');
            photoItem.className = 'photo-item';
            photoItem.dataset.itemIndex = index;

            if (thumbnail && thumbnail.url) {
              const img = document.createElement('img');
              img.src = thumbnail.url;
              img.alt = '';
              img.loading = 'lazy';
              photoItem.appendChild(img);
            } else {
              // No thumbnail found - create a placeholder
              console.warn('Skipped video (no thumbnail) for photo grid:', item.photoGuid);
              console.warn('Available derivatives:', Object.keys(item.derivatives || {}));
              const placeholder = document.createElement('div');
              placeholder.style.cssText = 'width: 100%; aspect-ratio: 1; background: #333; display: flex; align-items: center; justify-content: center; color: #999; font-size: 14px;';
              placeholder.textContent = 'Video';
              photoItem.appendChild(placeholder);
            }

            photoItem.addEventListener('click', () => openVideoLightbox(index));
            currentPhotoGrid.appendChild(photoItem);
            return; // Skip vlog post creation
          }
          
          // Video has augmentation (blog/transcription) - render as vlog post
          // Only render vlog posts for videos that have augmentations
          if (cachedAugmentation && (cachedAugmentation.blog || cachedAugmentation.transcription)) {
            // Close current photo grid if open
            if (currentPhotoGrid) {
              feed.appendChild(currentPhotoGrid);
              currentPhotoGrid = null;
            }

            // Create vlog post card with actual content
            const vlogPost = document.createElement('div');
            vlogPost.className = 'vlog-post';
            vlogPost.dataset.itemIndex = index;
            vlogPost.id = `vlog-post-${index}`;

            const thumbnail = getBestThumbnail(item);
            if (thumbnail && thumbnail.url) {
              const thumbImg = document.createElement('img');
              thumbImg.src = thumbnail.url;
              thumbImg.className = 'vlog-thumbnail';
              thumbImg.alt = '';
              thumbImg.onerror = function() {
                console.error('Failed to load video thumbnail:', thumbnail.url, item);
                this.style.display = 'none';
              };
              vlogPost.appendChild(thumbImg);
            }

            const content = document.createElement('div');
            content.className = 'vlog-content';

            const title = document.createElement('h2');
            title.className = 'vlog-title';
            
            const textPreview = document.createElement('div');
            textPreview.className = 'vlog-text-preview';
            
            if (cachedAugmentation.blog) {
              // Use actual blog content
              const titleText = cachedAugmentation.blog.split('\n')[0].replace(/^#+\s*/, '') || `Vlog Entry - ${formatDateShort(item.dateCreated)}`;
              title.textContent = titleText;
              
              // Extract first paragraph as preview
              const preview = cachedAugmentation.blog
                .split('\n\n')[0]
                .replace(/^#+\s*/, '')
                .substring(0, 200);
              textPreview.textContent = preview + (preview.length >= 200 ? '...' : '');
              
              vlogPost.classList.add('has-augmentation');
            } else if (cachedAugmentation.transcription) {
              // Use transcription
              title.textContent = `Vlog Entry - ${formatDateShort(item.dateCreated)}`;
              const preview = cachedAugmentation.transcription.substring(0, 200);
              textPreview.textContent = preview + (preview.length >= 200 ? '...' : '');
              vlogPost.classList.add('has-augmentation');
            }
            
            content.appendChild(title);
            content.appendChild(textPreview);

            const meta = document.createElement('div');
            meta.className = 'vlog-meta';
            const date = document.createElement('div');
            date.className = 'vlog-date';
            date.textContent = formatDate(item.dateCreated);
            meta.appendChild(date);
            content.appendChild(meta);
            vlogPost.appendChild(content);

            vlogPost.addEventListener('click', () => openVlogLightbox(index));
            feed.appendChild(vlogPost);
          } else {
            // Video has no augmentation (skipped, processing, or not processed) - treat as regular video in photo grid
            if (!currentPhotoGrid) {
              currentPhotoGrid = document.createElement('div');
              currentPhotoGrid.className = 'photo-grid';
            }

            const thumbnail = getBestThumbnail(item);
            const photoItem = document.createElement('div');
            photoItem.className = 'photo-item';
            photoItem.dataset.itemIndex = index;

            if (thumbnail && thumbnail.url) {
              const img = document.createElement('img');
              img.src = thumbnail.url;
              img.alt = '';
              img.loading = 'lazy';
              photoItem.appendChild(img);
            } else {
              // No thumbnail found - create a placeholder
              const placeholder = document.createElement('div');
              placeholder.style.cssText = 'width: 100%; aspect-ratio: 1; background: #333; display: flex; align-items: center; justify-content: center; color: #999; font-size: 14px;';
              placeholder.textContent = 'Video';
              photoItem.appendChild(placeholder);
            }

            photoItem.addEventListener('click', () => openVideoLightbox(index));
            currentPhotoGrid.appendChild(photoItem);
            
            // Still load augmentation in background in case it finishes processing
            if (!cachedAugmentation || cachedAugmentation.status === 'processing') {
              loadVideoAugmentation(index, item, token, null);
            }
          }
        } else {
          // Photo - add to current grid or create new grid
          if (!currentPhotoGrid) {
            currentPhotoGrid = document.createElement('div');
            currentPhotoGrid.className = 'photo-grid';
          }

          const thumbnail = getBestThumbnail(item);
          if (!thumbnail || !thumbnail.url) {
            return; // Skip photos without thumbnails
          }

          const photoItem = document.createElement('div');
          photoItem.className = 'photo-item';
          photoItem.dataset.itemIndex = index;

          const img = document.createElement('img');
          img.src = thumbnail.url;
          img.alt = '';
          img.loading = 'lazy';
          photoItem.appendChild(img);

          photoItem.addEventListener('click', () => openPhotoLightbox(index));
          currentPhotoGrid.appendChild(photoItem);
        }
      });

      // Close any remaining photo grid
      if (currentPhotoGrid) {
        feed.appendChild(currentPhotoGrid);
      }
    }

    function openVideoLightbox(itemIndex) {
      const item = items[itemIndex];
      if (!item || !isVideo(item)) return;

      const video = getBestVideo(item);
      if (!video || !video.url) return;

      const lightbox = document.getElementById('lightbox');
      const lightboxImage = document.getElementById('lightbox-image');
      const lightboxVideo = document.getElementById('lightbox-video');
      const lightboxInfo = document.getElementById('lightbox-info');

      // Hide image, show video
      lightboxImage.style.display = 'none';
      lightboxVideo.src = video.url;
      lightboxVideo.style.display = 'block';

      const caption = item.caption || '';
      const date = formatDate(item.dateCreated);
      lightboxInfo.innerHTML = caption 
        ? `<div>${caption}</div><div style="margin-top: 4px; opacity: 0.8; font-size: 12px;">${date}</div>`
        : `<div>${date}</div>`;

      lightbox.classList.add('active');
      document.body.classList.add('lightbox-open');
    }

    function openPhotoLightbox(itemIndex) {
      const item = items[itemIndex];
      if (!item) return;

      // Handle videos - open video lightbox for skipped videos (regular videos should use vlog lightbox)
      if (isVideo(item)) {
        const cacheKey = `${token}_${item.photoGuid}`;
        const cachedAugmentation = videoAugmentations.get(cacheKey);
        // If video is skipped, open in regular video lightbox (treat as regular video)
        if (cachedAugmentation && cachedAugmentation.skipped) {
          openVideoLightbox(itemIndex);
        } else {
          // Regular video with augmentation - use vlog lightbox
          openVlogLightbox(itemIndex);
        }
        return;
      }

      // Find index in photoItems array
      currentPhotoIndex = photoItems.findIndex(photo => photo === item);
      if (currentPhotoIndex === -1) return;

      const thumbnail = getBestThumbnail(item);
      if (!thumbnail || !thumbnail.url) return;

      const lightbox = document.getElementById('lightbox');
      const lightboxImage = document.getElementById('lightbox-image');
      const lightboxInfo = document.getElementById('lightbox-info');

      lightboxImage.src = thumbnail.url;
      lightboxImage.style.display = 'block';

      const caption = item.caption || '';
      const date = formatDate(item.dateCreated);
      lightboxInfo.innerHTML = caption 
        ? `<div>${caption}</div><div style="margin-top: 4px; opacity: 0.8; font-size: 12px;">${date}</div>`
        : `<div>${date}</div>`;

      lightbox.classList.add('active');
      document.body.classList.add('lightbox-open');
    }

    // Load video augmentation asynchronously and update the UI
    // This is called after initial render for videos that are still processing
    async function loadVideoAugmentation(index, item, albumToken, vlogPostElement) {
      try {
        const augmentation = await fetchVideoAugmentation(albumToken, item.photoGuid, false);
        
        // If video was skipped or has no augmentation, it's already rendered as a photo item
        // No action needed - it's already in the photo grid
        
        // If video now has augmentation and was rendered as a photo, we'd need to convert it
        // But for now, we'll leave it as-is since it's rare for processing to complete
        // during a page session. The next page load will render it correctly.
        
        if (augmentation && (augmentation.blog || augmentation.transcription) && vlogPostElement) {
          // Update existing vlog post with new content
          const titleElement = vlogPostElement.querySelector('.vlog-title');
          const textPreviewElement = vlogPostElement.querySelector('.vlog-text-preview');
          
          if (titleElement && textPreviewElement) {
            if (augmentation.blog) {
              const titleText = augmentation.blog.split('\n')[0].replace(/^#+\s*/, '') || `Vlog Entry - ${formatDateShort(item.dateCreated)}`;
              titleElement.textContent = titleText;
              const preview = augmentation.blog
                .split('\n\n')[0]
                .replace(/^#+\s*/, '')
                .substring(0, 200);
              textPreviewElement.textContent = preview + (preview.length >= 200 ? '...' : '');
              vlogPostElement.classList.remove('processing');
              vlogPostElement.classList.add('has-augmentation');
            } else if (augmentation.transcription) {
              titleElement.textContent = `Vlog Entry - ${formatDateShort(item.dateCreated)}`;
              const preview = augmentation.transcription.substring(0, 200);
              textPreviewElement.textContent = preview + (preview.length >= 200 ? '...' : '');
              vlogPostElement.classList.remove('processing');
              vlogPostElement.classList.add('has-augmentation');
            }
          }
        }
      } catch (error) {
        console.error(`Error loading augmentation for video ${index}:`, error);
      }
    }

    async function openVlogLightbox(itemIndex) {
      const item = items[itemIndex];
      if (!item || !isVideo(item)) return;

      const video = getBestVideo(item);
      if (!video || !video.url) return;

      const vlogLightbox = document.getElementById('vlog-lightbox');
      const vlogVideo = document.getElementById('vlog-lightbox-video');
      const vlogTitle = document.getElementById('vlog-lightbox-title');
      const vlogDate = document.getElementById('vlog-lightbox-date');
      const vlogPost = document.getElementById('vlog-lightbox-post');

      const vlogContent = await generateVlogContent(item, token);

      vlogVideo.src = video.url;
      vlogTitle.textContent = vlogContent.title;
      vlogDate.textContent = formatDate(item.dateCreated);
      
      // Display blog content as markdown using marked library
      if (vlogContent.hasAugmentation && vlogContent.text) {
        // Use marked to convert markdown to HTML
        if (typeof marked !== 'undefined') {
          vlogPost.innerHTML = marked.parse(vlogContent.text);
        } else {
          // Fallback to simple conversion if marked is not loaded
          let html = vlogContent.text
            .split('\n\n') // Paragraphs
            .map(para => {
              // Headers
              if (para.startsWith('### ')) {
                return `<h3>${para.substring(4)}</h3>`;
              } else if (para.startsWith('## ')) {
                return `<h2>${para.substring(3)}</h2>`;
              } else if (para.startsWith('# ')) {
                return `<h1>${para.substring(2)}</h1>`;
              }
              // Regular paragraph
              return `<p>${para.replace(/\n/g, '<br>')}</p>`;
            })
            .join('');
          vlogPost.innerHTML = html;
        }
      } else {
        // Placeholder or processing message
        vlogPost.innerHTML = `<p>${vlogContent.text.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>')}</p>`;
      }

      vlogLightbox.classList.add('active');
      document.body.classList.add('lightbox-open');
      vlogVideo.play();

      // Setup picture-in-picture scroll detection for mobile
      setupVlogPIP();
    }

    // Setup picture-in-picture for vlog lightbox on mobile
    function setupVlogPIP() {
      const vlogLightbox = document.getElementById('vlog-lightbox');
      const vlogVideoContainer = document.querySelector('.vlog-lightbox-video');
      const vlogText = document.querySelector('.vlog-lightbox-text');
      
      if (!vlogLightbox || !vlogVideoContainer || !vlogText) return;

      // Only enable on mobile devices
      const isMobile = window.innerWidth <= 968;
      if (!isMobile) return;

      // Handle scroll - check if video is scrolled out of view
      const handleScroll = () => {
        if (!vlogLightbox.classList.contains('active')) return;

        // Check if video is scrolled out of view (top of video is above viewport)
        const rect = vlogVideoContainer.getBoundingClientRect();
        const isVideoOutOfView = rect.bottom < 50; // 50px threshold

        // If video is scrolled out of view, enable PIP mode
        if (isVideoOutOfView) {
          vlogVideoContainer.classList.add('pip-mode');
          vlogText.classList.add('pip-active');
        } else {
          vlogVideoContainer.classList.remove('pip-mode');
          vlogText.classList.remove('pip-active');
        }
      };

      // Listen to scroll on the lightbox container (which is scrollable)
      vlogLightbox.addEventListener('scroll', handleScroll);
      
      // Also use IntersectionObserver for better performance
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (!vlogLightbox.classList.contains('active')) return;
          
          // If video is not intersecting (scrolled out of view), enable PIP
          if (!entry.isIntersecting) {
            vlogVideoContainer.classList.add('pip-mode');
            vlogText.classList.add('pip-active');
          } else {
            vlogVideoContainer.classList.remove('pip-mode');
            vlogText.classList.remove('pip-active');
          }
        });
      }, {
        root: vlogLightbox,
        threshold: 0,
        rootMargin: '-50px 0px 0px 0px' // Trigger when video is 50px from top
      });

      // Observe the video container
      observer.observe(vlogVideoContainer);

      // Clean up when lightbox closes
      const closeObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (!vlogLightbox.classList.contains('active')) {
            vlogVideoContainer.classList.remove('pip-mode');
            vlogText.classList.remove('pip-active');
            vlogLightbox.removeEventListener('scroll', handleScroll);
            observer.disconnect();
            closeObserver.disconnect();
          }
        });
      });

      closeObserver.observe(vlogLightbox, { attributes: true, attributeFilter: ['class'] });
    }

    // Lightbox controls
    document.getElementById('lightbox-close').addEventListener('click', (e) => {
      e.stopPropagation();
      document.getElementById('lightbox').classList.remove('active');
      document.body.classList.remove('lightbox-open');
      document.getElementById('lightbox-video').pause();
    });

    document.getElementById('lightbox').addEventListener('click', (e) => {
      if (e.target.id === 'lightbox') {
        document.getElementById('lightbox').classList.remove('active');
      document.body.classList.remove('lightbox-open');
        document.getElementById('lightbox-video').pause();
      }
    });

    document.getElementById('lightbox-prev').addEventListener('click', (e) => {
      e.stopPropagation();
      if (currentPhotoIndex > 0) {
        currentPhotoIndex--;
        const item = photoItems[currentPhotoIndex];
        const itemIndex = items.findIndex(i => i === item);
        if (itemIndex !== -1) {
          openPhotoLightbox(itemIndex);
        }
      }
    });

    document.getElementById('lightbox-next').addEventListener('click', (e) => {
      e.stopPropagation();
      if (currentPhotoIndex < photoItems.length - 1) {
        currentPhotoIndex++;
        const item = photoItems[currentPhotoIndex];
        const itemIndex = items.findIndex(i => i === item);
        if (itemIndex !== -1) {
          openPhotoLightbox(itemIndex);
        }
      }
    });

    document.getElementById('vlog-lightbox-close').addEventListener('click', () => {
      const vlogLightbox = document.getElementById('vlog-lightbox');
      const vlogVideo = document.getElementById('vlog-lightbox-video');
      const vlogVideoContainer = document.querySelector('.vlog-lightbox-video');
      const vlogText = document.querySelector('.vlog-lightbox-text');
      
      vlogLightbox.classList.remove('active');
      document.body.classList.remove('lightbox-open');
      
      // Reset PIP mode
      if (vlogVideoContainer) vlogVideoContainer.classList.remove('pip-mode');
      if (vlogText) vlogText.classList.remove('pip-active');
      
      vlogVideo.pause();
      vlogVideo.src = '';
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      const lightbox = document.getElementById('lightbox');
      const vlogLightbox = document.getElementById('vlog-lightbox');

      if (lightbox.classList.contains('active')) {
        if (e.key === 'Escape') {
          lightbox.classList.remove('active');
          document.body.classList.remove('lightbox-open');
          document.getElementById('lightbox-video').pause();
        } else if (e.key === 'ArrowLeft') {
          document.getElementById('lightbox-prev').click();
        } else if (e.key === 'ArrowRight') {
          document.getElementById('lightbox-next').click();
        }
      } else if (vlogLightbox.classList.contains('active')) {
        if (e.key === 'Escape') {
          document.getElementById('vlog-lightbox-close').click();
        }
      }
    });

    // Touch swipe for photo lightbox
    document.getElementById('lightbox').addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
    });

    document.getElementById('lightbox').addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      handleSwipe();
    });

    function handleSwipe() {
      const swipeThreshold = 50;
      const diff = touchStartX - touchEndX;

      if (Math.abs(diff) > swipeThreshold) {
        if (diff > 0) {
          // Swipe left - next
          document.getElementById('lightbox-next').click();
        } else {
          // Swipe right - previous
          document.getElementById('lightbox-prev').click();
        }
      }
    }
  </script>
</body>
</html>

